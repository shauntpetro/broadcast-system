<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OBS Slideshow</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; background: #0a0a0a; overflow: hidden; font-family: system-ui, -apple-system, sans-serif; }
    
    @keyframes ken-burns-zoom-in { from { transform: scale(1); } to { transform: scale(1.12); } }
    @keyframes ken-burns-zoom-out { from { transform: scale(1.12); } to { transform: scale(1); } }
    @keyframes ken-burns-pan-left { from { transform: translateX(3%) scale(1.08); } to { transform: translateX(-3%) scale(1.08); } }
    @keyframes ken-burns-pan-right { from { transform: translateX(-3%) scale(1.08); } to { transform: translateX(3%) scale(1.08); } }
    
    .kb-zoom-in { animation: ken-burns-zoom-in var(--kb-duration, 30s) linear forwards; }
    .kb-zoom-out { animation: ken-burns-zoom-out var(--kb-duration, 30s) linear forwards; }
    .kb-pan-left { animation: ken-burns-pan-left var(--kb-duration, 30s) linear forwards; }
    .kb-pan-right { animation: ken-burns-pan-right var(--kb-duration, 30s) linear forwards; }
    
    /* Transition system - duration controlled by CSS variable */
    .slide-container {
      transition: transform var(--transition-duration, 0.4s) ease-out,
                  filter var(--transition-duration, 0.4s) ease-out,
                  opacity var(--transition-duration, 0.4s) ease-out;
    }

    /* ===== EXIT ANIMATIONS ===== */
    /* Cut - instant switch */
    .transition-cut .slide-container { transition: none; }
    .transition-cut .slide-exit { opacity: 0; }

    /* Fade - crossfade */
    .transition-fade .slide-exit { opacity: 0; }

    /* Blur - blur out/in */
    .transition-blur .slide-exit { filter: blur(30px); opacity: 0; transform: scale(0.95); }

    /* Slide Left - slide exits to left */
    .transition-slideLeft .slide-exit { transform: translateX(-100%); }

    /* Slide Right - slide exits to right */
    .transition-slideRight .slide-exit { transform: translateX(100%); }

    /* Zoom - zoom out */
    .transition-zoom .slide-exit { transform: scale(0.5); opacity: 0; }

    /* Whip Pan - fast motion blur exit */
    .transition-whipPan .slide-exit { transform: translateX(-100%) skewX(-5deg); filter: blur(10px); opacity: 0; }

    /* ===== ENTER ANIMATIONS ===== */
    /* Fade enter */
    @keyframes fade-enter {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Blur enter */
    @keyframes blur-enter {
      from { filter: blur(30px); opacity: 0; transform: scale(1.05); }
      to { filter: blur(0); opacity: 1; transform: scale(1); }
    }

    /* Slide Left enter - enters from right */
    @keyframes slideLeft-enter {
      from { transform: translateX(100%); }
      to { transform: translateX(0); }
    }

    /* Slide Right enter - enters from left */
    @keyframes slideRight-enter {
      from { transform: translateX(-100%); }
      to { transform: translateX(0); }
    }

    /* Zoom enter */
    @keyframes zoom-enter {
      from { transform: scale(1.5); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    /* Whip Pan enter */
    @keyframes whipPan-enter {
      from { transform: translateX(100%) skewX(5deg); filter: blur(10px); opacity: 0; }
      to { transform: translateX(0) skewX(0); filter: blur(0); opacity: 1; }
    }

    /* Apply enter animations - use 'both' fill-mode to start from 'from' state and stay at 'to' state */
    /* Also disable transition to prevent conflicts and allow overflow for slide animations */
    .slide-enter-fade,
    .slide-enter-blur,
    .slide-enter-slideLeft,
    .slide-enter-slideRight,
    .slide-enter-zoom,
    .slide-enter-whipPan {
      overflow: visible !important;
    }

    .slide-enter-fade .slide-container {
      animation: fade-enter var(--transition-duration, 0.4s) ease-out both !important;
      transition: none !important;
    }
    .slide-enter-blur .slide-container {
      animation: blur-enter var(--transition-duration, 0.4s) ease-out both !important;
      transition: none !important;
    }
    .slide-enter-slideLeft .slide-container {
      animation: slideLeft-enter var(--transition-duration, 0.4s) ease-out both !important;
      transition: none !important;
    }
    .slide-enter-slideRight .slide-container {
      animation: slideRight-enter var(--transition-duration, 0.4s) ease-out both !important;
      transition: none !important;
    }
    .slide-enter-zoom .slide-container {
      animation: zoom-enter var(--transition-duration, 0.4s) ease-out both !important;
      transition: none !important;
    }
    .slide-enter-whipPan .slide-container {
      animation: whipPan-enter var(--transition-duration, 0.4s) ease-out both !important;
      transition: none !important;
    }

    /* Allow overflow during slide transitions so content can move off-screen */
    .transition-slideLeft,
    .transition-slideRight,
    .transition-whipPan {
      overflow: visible !important;
    }

    /* Legacy classes for backwards compatibility */
    .slide-exit-right { transform: translateX(-100%) scale(0.9); filter: blur(20px); opacity: 0; }
    .slide-exit-left { transform: translateX(100%) scale(0.9); filter: blur(20px); opacity: 0; }
    
    .scrollbar::-webkit-scrollbar { width: 6px; }
    .scrollbar::-webkit-scrollbar-track { background: transparent; }
    .scrollbar::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    .scrollbar::-webkit-scrollbar-thumb:hover { background: #444; }
    
    input[type="text"], textarea, select {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: white;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 13px;
      width: 100%;
      outline: none;
    }
    input[type="text"]:focus, textarea:focus, select:focus { border-color: #ef4444; }
    textarea { resize: none; }
    
    input[type="range"] { 
      -webkit-appearance: none; 
      background: rgba(255,255,255,0.1); 
      height: 6px; 
      border-radius: 3px;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #ef4444;
      border-radius: 50%;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <script>
    // Check URL params
    const urlParams = new URLSearchParams(window.location.search);
    const isOBSMode = urlParams.get('obs') === '1' || urlParams.get('output') === '1';

    // State (global for cross-window access)
    window.slides = [];
    window.currentIndex = 0;
    window.isPlaying = false;
    window.stateVersion = 0;  // Increments on any state change for fast sync detection

    // Global settings
    window.globalSettings = {
      transition: 'blur',        // cut, fade, blur, slideLeft, slideRight, zoom, whipPan
      transitionDuration: 0.4,   // seconds
      defaultKenBurns: 'none',
      defaultKenBurnsDuration: 30
    };

    let slides = window.slides;
    let currentIndex = window.currentIndex;
    let isPlaying = window.isPlaying;
    let globalSettings = window.globalSettings;
    let isTransitioning = false;
    let editingSlideId = null;
    let showSettings = false;

    // ============ WEBSOCKET SYNC ============
    let ws = null;
    let wsReconnectAttempts = 0;
    const maxWsReconnectAttempts = 10;

    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}`;

      try {
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          console.log('[Slideshow WS] Connected');
          wsReconnectAttempts = 0;
          if (isOBSMode) {
            // OBS mode: request current state from server
            ws.send(JSON.stringify({ type: 'slideshow_get' }));
          } else {
            // Control panel: sync current state to server (after small delay to ensure state is loaded)
            setTimeout(() => {
              if (slides.length > 0) {
                console.log('[Slideshow WS] Syncing', slides.length, 'slides to server');
                broadcastToServer();
              }
            }, 500);
          }
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            handleWsMessage(data);
          } catch (e) {
            console.error('[Slideshow WS] Parse error:', e);
          }
        };

        ws.onclose = () => {
          console.log('[Slideshow WS] Disconnected');
          // Attempt reconnect
          if (wsReconnectAttempts < maxWsReconnectAttempts) {
            wsReconnectAttempts++;
            setTimeout(connectWebSocket, 2000 * wsReconnectAttempts);
          }
        };

        ws.onerror = (error) => {
          console.error('[Slideshow WS] Error:', error);
        };
      } catch (e) {
        console.error('[Slideshow WS] Failed to connect:', e);
      }
    }

    function handleWsMessage(data) {
      if (data.type === 'slideshow_init' || data.type === 'slideshow_update') {
        const slideData = data.data || data;
        const slideChanged = currentIndex !== slideData.currentIndex;

        // Update state from server
        if (slideData.slides) slides = slideData.slides;
        if (slideData.currentIndex !== undefined) currentIndex = slideData.currentIndex;
        if (slideData.isPlaying !== undefined) isPlaying = slideData.isPlaying;
        if (slideData.globalSettings) globalSettings = slideData.globalSettings;

        // Sync to window
        window.slides = slides;
        window.currentIndex = currentIndex;
        window.isPlaying = isPlaying;
        window.globalSettings = globalSettings;
        window.stateVersion++;

        console.log('[Slideshow WS] Received state update, slides:', slides.length, 'index:', currentIndex);

        if (isOBSMode) {
          renderOBS(slideChanged);
        } else {
          renderFull();
        }
      }
    }

    function wsSend(type, data = {}) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type, ...data }));
      }
    }

    // Broadcast state to server (for sync with OBS)
    function broadcastToServer() {
      wsSend('slideshow_sync', {
        slides: slides,
        currentIndex: currentIndex,
        isPlaying: isPlaying,
        globalSettings: globalSettings
      });
    }

    // Keep window references in sync
    function syncWindowState() {
      window.slides = slides;
      window.currentIndex = currentIndex;
      window.isPlaying = isPlaying;
      window.globalSettings = globalSettings;
      window.stateVersion++;  // Increment version on every state change
    }

    function broadcast() {
      syncWindowState();
      pushToOBS();
      // Also broadcast to server for WebSocket-connected OBS windows
      broadcastToServer();
    }
    
    // Function called by parent window to update OBS
    window.receiveUpdate = function(newSlides, newIndex, newPlaying) {
      const slideChanged = currentIndex !== newIndex;
      slides = newSlides;
      currentIndex = newIndex;
      isPlaying = newPlaying;
      if (isOBSMode) {
        console.log('OBS receiveUpdate: slideChanged:', slideChanged);
        renderOBS(slideChanged);
      }
    };

    // File handling
    function getFileType(file) {
      if (file.type?.startsWith('video/')) return 'video';
      if (file.type?.startsWith('image/')) return 'image';
      const ext = file.name.split('.').pop()?.toLowerCase();
      if (['mp4','webm','ogg','mov','avi','mkv','m4v'].includes(ext)) return 'video';
      return 'image';
    }

    // Upload file to server and return URL
    async function uploadFileToServer(file) {
      const formData = new FormData();
      formData.append('file', file);

      try {
        const response = await fetch('/api/upload', {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          throw new Error('Upload failed');
        }

        const result = await response.json();
        return result;
      } catch (error) {
        console.error('[Upload] Error:', error);
        // Fallback to blob URL if upload fails
        return {
          url: URL.createObjectURL(file),
          type: getFileType(file),
          originalName: file.name,
          fallback: true
        };
      }
    }

    async function handleFileUpload(e) {
      const files = Array.from(e.target.files);
      e.target.value = '';

      // Show loading state
      const loadingCount = files.length;
      console.log(`[Upload] Uploading ${loadingCount} files...`);

      // Upload files in parallel
      const uploadPromises = files.map(async (file) => {
        const result = await uploadFileToServer(file);
        const slideIndex = slides.length;
        const alternatingKenBurns = (slideIndex % 2 === 0) ? 'zoomIn' : 'zoomOut';

        const slide = {
          id: Date.now() + Math.random(),
          url: result.url,
          type: result.type || getFileType(file),
          fileName: result.originalName || file.name,
          name: (result.originalName || file.name).replace(/\.[^/.]+$/, ""),
          notes: '',
          title: '',
          subtitle: '',
          quote: '',
          quoteAuthor: '',
          kenBurns: alternatingKenBurns,
          kenBurnsDuration: globalSettings.defaultKenBurnsDuration,
          serverFilename: result.filename, // Track server filename for deletion
          fitMode: 'contain', // contain, cover, or fill
          zoom: 100 // zoom percentage (100 = normal)
        };

        slides.push(slide);
        return slide;
      });

      await Promise.all(uploadPromises);

      console.log(`[Upload] Complete. ${slides.length} total slides.`);
      syncWindowState();
      renderFull();
      broadcast();
    }

    // Navigation with transition effects - TRUE CROSSFADE
    // Both old and new slides exist simultaneously during transition
    function goToSlide(index) {
      if (isTransitioning || slides.length === 0 || index === currentIndex) return;
      isTransitioning = true;

      const transition = globalSettings.transition;
      const duration = globalSettings.transitionDuration;
      const durationMs = duration * 1000;

      // Cut transition - instant switch, no animation
      if (transition === 'cut') {
        currentIndex = index;
        syncWindowState();
        renderFull();
        broadcast();
        isTransitioning = false;
        return;
      }

      // Set transition duration CSS variable
      document.documentElement.style.setProperty('--transition-duration', duration + 's');

      const previewBox = document.getElementById('preview-box');
      if (!previewBox) {
        currentIndex = index;
        syncWindowState();
        renderFull();
        broadcast();
        isTransitioning = false;
        return;
      }

      // Get the OLD slide's current content
      const oldSlide = slides[currentIndex];
      const newSlide = slides[index];

      // Wrap all existing content in an exit layer
      const exitLayer = document.createElement('div');
      exitLayer.id = 'exit-layer';
      exitLayer.className = 'absolute inset-0';

      // Move all current children into the exit layer
      while (previewBox.firstChild) {
        exitLayer.appendChild(previewBox.firstChild);
      }
      previewBox.appendChild(exitLayer);

      // Create the entering slide layer
      const enterLayer = document.createElement('div');
      enterLayer.id = 'enter-layer';
      enterLayer.className = 'absolute inset-0 z-10';
      enterLayer.innerHTML = renderPreviewContent(newSlide);

      // Set initial state for the entering layer
      switch (transition) {
        case 'fade':
          enterLayer.style.opacity = '0';
          break;
        case 'blur':
          enterLayer.style.opacity = '0';
          enterLayer.style.filter = 'blur(30px)';
          enterLayer.style.transform = 'scale(1.05)';
          break;
        case 'slideLeft':
          enterLayer.style.transform = 'translateX(100%)';
          break;
        case 'slideRight':
          enterLayer.style.transform = 'translateX(-100%)';
          break;
        case 'zoom':
          enterLayer.style.opacity = '0';
          enterLayer.style.transform = 'scale(1.5)';
          break;
        case 'whipPan':
          enterLayer.style.opacity = '0';
          enterLayer.style.transform = 'translateX(100%) skewX(5deg)';
          enterLayer.style.filter = 'blur(10px)';
          break;
      }

      // Add the entering layer
      previewBox.appendChild(enterLayer);

      // Animate both layers
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // Animate exit layer OUT
          exitLayer.style.transition = `all ${duration}s ease-out`;
          switch (transition) {
            case 'fade':
              exitLayer.style.opacity = '0';
              break;
            case 'blur':
              exitLayer.style.opacity = '0';
              exitLayer.style.filter = 'blur(30px)';
              exitLayer.style.transform = 'scale(0.95)';
              break;
            case 'slideLeft':
              exitLayer.style.transform = 'translateX(-100%)';
              break;
            case 'slideRight':
              exitLayer.style.transform = 'translateX(100%)';
              break;
            case 'zoom':
              exitLayer.style.opacity = '0';
              exitLayer.style.transform = 'scale(0.5)';
              break;
            case 'whipPan':
              exitLayer.style.opacity = '0';
              exitLayer.style.transform = 'translateX(-100%) skewX(-5deg)';
              exitLayer.style.filter = 'blur(10px)';
              break;
          }

          // Animate enter layer IN
          enterLayer.style.transition = `all ${duration}s ease-out`;
          enterLayer.style.opacity = '1';
          enterLayer.style.filter = 'none';
          enterLayer.style.transform = 'none';
        });
      });

      // After transition completes, clean up and update state
      setTimeout(() => {
        currentIndex = index;
        syncWindowState();
        renderFull();
        broadcast();
        isTransitioning = false;
      }, durationMs + 50); // Small buffer for cleanup
    }

    function goNext() { if (slides.length) goToSlide((currentIndex + 1) % slides.length); }
    function goPrev() { if (slides.length) goToSlide((currentIndex - 1 + slides.length) % slides.length); }

    function togglePlay() {
      const mainVideo = document.getElementById('mainVideo');
      const bgVideo = document.getElementById('bgVideo');
      if (mainVideo) {
        if (mainVideo.paused) {
          mainVideo.play();
          if (bgVideo) bgVideo.play();
        } else {
          mainVideo.pause();
          if (bgVideo) bgVideo.pause();
        }
        isPlaying = !mainVideo.paused;
        syncWindowState();
        updateNavBar();
        broadcast();
      }
    }

    function deleteSlide(id) {
      const idx = slides.findIndex(s => s.id === id);
      if (idx !== -1) {
        const slide = slides[idx];

        // Delete file from server if it was uploaded there
        if (slide.serverFilename) {
          fetch(`/api/upload/${slide.serverFilename}`, { method: 'DELETE' })
            .then(res => res.json())
            .then(result => console.log('[Delete] Server file deleted:', slide.serverFilename))
            .catch(err => console.warn('[Delete] Failed to delete server file:', err));
        }

        slides.splice(idx, 1); // Use splice to maintain array reference
        if (currentIndex >= slides.length) currentIndex = Math.max(0, slides.length - 1);
        editingSlideId = null;
        syncWindowState();
        renderFull();
        broadcast();
      }
    }

    let obsWindow = null;
    
    function openOBSWindow() {
      obsWindow = window.open(location.href.split('?')[0] + '?obs=1', 'OBS', 'width=1920,height=1080');
      // Give it time to load, then push initial state
      setTimeout(() => {
        pushToOBS();
      }, 500);
    }
    
    // Push current state to OBS window (backup mechanism - polling is primary)
    function pushToOBS() {
      if (obsWindow && !obsWindow.closed) {
        try {
          // Trigger immediate render in OBS window if it has the function
          if (typeof obsWindow.receiveUpdate === 'function') {
            obsWindow.receiveUpdate(slides, currentIndex, isPlaying);
          }
        } catch (e) {
          // Cross-origin or window closed - polling will handle sync
        }
      }
    }

    // Check if OBS window is connected
    function isOBSConnected() {
      return obsWindow && !obsWindow.closed;
    }

    // Update OBS button status indicator
    function updateOBSButtonStatus() {
      const container = document.getElementById('obs-button-container');
      if (container) {
        const connected = isOBSConnected();
        container.innerHTML = `
          <button onclick="openOBSWindow()" class="w-full ${connected ? 'bg-green-600 hover:bg-green-700' : 'bg-purple-600 hover:bg-purple-700'} text-white text-sm py-2 rounded-lg flex items-center justify-center gap-2">
            ${connected ? `<span class="w-2 h-2 bg-white rounded-full animate-pulse"></span>` : `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/></svg>`}
            ${connected ? 'OBS Connected' : 'OBS Output Window'}
          </button>`;
      }
    }

    // Check OBS connection status periodically (only in main window)
    if (!isOBSMode) {
      setInterval(updateOBSButtonStatus, 1000);
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
      if (e.key === 'ArrowRight') { e.preventDefault(); goNext(); }
      if (e.key === 'ArrowLeft') { e.preventDefault(); goPrev(); }
      if (e.key === ' ') { e.preventDefault(); togglePlay(); }
      if (e.key === 'Escape') { editingSlideId = null; renderFull(); }
    });

    // ============ RENDERING ============

    // Track current OBS slide to avoid unnecessary re-renders
    let obsCurrentSlideId = null;
    let obsIsTransitioning = false;

    // Generate OBS slide HTML content
    function generateOBSSlideHTML(slide) {
      const kb = slide.kenBurns;
      const kbClass = kb === 'zoomIn' ? 'kb-zoom-in' : kb === 'zoomOut' ? 'kb-zoom-out' : kb === 'panLeft' ? 'kb-pan-left' : kb === 'panRight' ? 'kb-pan-right' : '';

      // Fit mode classes
      const fitMode = slide.fitMode || 'contain';
      let fitClass = 'max-w-full max-h-full object-contain'; // default: contain
      if (fitMode === 'cover') {
        fitClass = 'w-full h-full object-cover';
      } else if (fitMode === 'fill') {
        fitClass = 'w-full h-full object-fill';
      }

      // Zoom transform
      const zoom = slide.zoom || 100;
      const zoomStyle = zoom !== 100 ? `transform: scale(${zoom / 100});` : '';

      return `
        <div class="absolute inset-0 scale-150">
          ${slide.type === 'video' ?
            `<video class="obs-bg-video w-full h-full object-cover blur-3xl opacity-50" src="${slide.url}" muted loop></video>` :
            `<img src="${slide.url}" class="w-full h-full object-cover blur-3xl opacity-50">`}
        </div>
        <div class="absolute inset-0 bg-gradient-to-b from-black/20 via-transparent to-black/40"></div>
        <div class="slide-container absolute inset-0 flex items-center justify-center overflow-hidden">
          ${slide.type === 'video' ?
            `<video class="obs-main-video ${fitClass} ${kbClass}" src="${slide.url}" style="--kb-duration:${slide.kenBurnsDuration}s; ${zoomStyle}" loop playsinline></video>` :
            `<img src="${slide.url}" class="${fitClass} ${kbClass}" style="--kb-duration:${slide.kenBurnsDuration}s; ${zoomStyle}">`}
        </div>
        <div class="obs-quote-container"></div>
        <div class="obs-title-container"></div>`;
    }

    // Render OBS output with TRUE CROSSFADE transitions
    function renderOBS(applyEnterTransition = false) {
      const slide = slides[currentIndex];
      const app = document.getElementById('app');

      console.log('OBS renderOBS called:',
                  'applyEnterTransition:', applyEnterTransition,
                  'currentIndex:', currentIndex,
                  'slide:', slide?.id,
                  'obsCurrentSlideId:', obsCurrentSlideId);

      if (!slide) {
        app.innerHTML = `<div class="w-screen h-screen bg-black flex items-center justify-center"><p class="text-gray-700">Waiting for slides...</p></div>`;
        obsCurrentSlideId = null;
        return;
      }

      // Check if we need full re-render (slide changed) or just update text/effects
      const needsFullRender = obsCurrentSlideId !== slide.id;
      console.log('OBS: needsFullRender:', needsFullRender);

      if (needsFullRender) {
        // Get transition settings from parent window
        const transition = window.opener?.globalSettings?.transition || globalSettings?.transition || 'blur';
        const duration = window.opener?.globalSettings?.transitionDuration || globalSettings?.transitionDuration || 0.4;

        // Set transition duration CSS variable
        document.documentElement.style.setProperty('--transition-duration', duration + 's');

        // If already transitioning, skip this render entirely
        if (obsIsTransitioning) {
          console.log('OBS: Skipping render - transition already in progress');
          return;
        }

        // If this is the first slide or cut transition, do instant render
        if (!obsCurrentSlideId || transition === 'cut' || !applyEnterTransition) {
          console.log('OBS: Instant render because:',
                      !obsCurrentSlideId ? 'no current slide' : '',
                      transition === 'cut' ? 'cut transition' : '',
                      !applyEnterTransition ? 'no enter transition requested' : '');
          obsCurrentSlideId = slide.id;
          app.innerHTML = `
            <div id="obs-slide-wrapper" class="w-screen h-screen bg-black overflow-hidden relative">
              ${generateOBSSlideHTML(slide)}
            </div>`;
          updateOBSTextOverlays(slide);
          return;
        }

        // TRUE CROSSFADE: Both slides visible during transition
        obsIsTransitioning = true;
        console.log('OBS: Starting transition', transition, 'duration:', duration);

        // Get current wrapper
        const currentWrapper = document.getElementById('obs-slide-wrapper');
        if (!currentWrapper) {
          console.log('OBS: No wrapper found, doing instant render');
          obsCurrentSlideId = slide.id;
          app.innerHTML = `
            <div id="obs-slide-wrapper" class="w-screen h-screen bg-black overflow-hidden relative">
              ${generateOBSSlideHTML(slide)}
            </div>`;
          updateOBSTextOverlays(slide);
          obsIsTransitioning = false;
          return;
        }

        // Allow overflow for slide transitions
        if (['slideLeft', 'slideRight', 'whipPan'].includes(transition)) {
          currentWrapper.style.overflow = 'visible';
        }

        // Wrap all existing content in an exit layer
        const exitLayer = document.createElement('div');
        exitLayer.id = 'obs-exit-layer';
        exitLayer.className = 'absolute inset-0';

        // Move all current children into the exit layer
        while (currentWrapper.firstChild) {
          exitLayer.appendChild(currentWrapper.firstChild);
        }
        currentWrapper.appendChild(exitLayer);

        // Create entering layer with new slide
        const enterLayer = document.createElement('div');
        enterLayer.id = 'obs-enter-layer';
        enterLayer.className = 'absolute inset-0 z-10';
        enterLayer.innerHTML = generateOBSSlideHTML(slide);

        console.log('OBS: Created exit and enter layers');

        // Set initial state for the ENTIRE entering layer
        switch (transition) {
          case 'fade':
            enterLayer.style.opacity = '0';
            break;
          case 'blur':
            enterLayer.style.opacity = '0';
            enterLayer.style.filter = 'blur(30px)';
            enterLayer.style.transform = 'scale(1.05)';
            break;
          case 'slideLeft':
            enterLayer.style.transform = 'translateX(100%)';
            break;
          case 'slideRight':
            enterLayer.style.transform = 'translateX(-100%)';
            break;
          case 'zoom':
            enterLayer.style.opacity = '0';
            enterLayer.style.transform = 'scale(1.5)';
            break;
          case 'whipPan':
            enterLayer.style.opacity = '0';
            enterLayer.style.transform = 'translateX(100%) skewX(5deg)';
            enterLayer.style.filter = 'blur(10px)';
            break;
        }

        // Add entering layer
        currentWrapper.appendChild(enterLayer);

        // Animate both layers
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            // Animate exit layer OUT
            exitLayer.style.transition = `all ${duration}s ease-out`;
            switch (transition) {
              case 'fade':
                exitLayer.style.opacity = '0';
                break;
              case 'blur':
                exitLayer.style.opacity = '0';
                exitLayer.style.filter = 'blur(30px)';
                exitLayer.style.transform = 'scale(0.95)';
                break;
              case 'slideLeft':
                exitLayer.style.transform = 'translateX(-100%)';
                break;
              case 'slideRight':
                exitLayer.style.transform = 'translateX(100%)';
                break;
              case 'zoom':
                exitLayer.style.opacity = '0';
                exitLayer.style.transform = 'scale(0.5)';
                break;
              case 'whipPan':
                exitLayer.style.opacity = '0';
                exitLayer.style.transform = 'translateX(-100%) skewX(-5deg)';
                exitLayer.style.filter = 'blur(10px)';
                break;
            }

            // Animate enter layer IN
            enterLayer.style.transition = `all ${duration}s ease-out`;
            enterLayer.style.opacity = '1';
            enterLayer.style.filter = 'none';
            enterLayer.style.transform = 'none';
          });
        });

        // Capture current slide for cleanup
        const newSlideId = slide.id;

        // After transition, clean up
        setTimeout(() => {
          obsCurrentSlideId = newSlideId;
          app.innerHTML = `
            <div id="obs-slide-wrapper" class="w-screen h-screen bg-black overflow-hidden relative">
              ${generateOBSSlideHTML(slides[currentIndex])}
            </div>`;
          updateOBSTextOverlays(slides[currentIndex]);
          obsIsTransitioning = false;
        }, duration * 1000 + 50);

      } else {
        // Just update text overlays without touching video
        updateOBSTextOverlays(slide);
      }
    }

    // Update only text overlays in OBS view (no video rebuild)
    function updateOBSTextOverlays(slide) {
      const quoteContainer = document.querySelector('.obs-quote-container');
      const titleContainer = document.querySelector('.obs-title-container');

      if (quoteContainer) {
        quoteContainer.innerHTML = slide.quote ? `
          <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center max-w-4xl px-8 z-10">
            <div class="bg-black/60 backdrop-blur-md rounded-xl p-8 border border-white/10">
              <p class="text-white text-3xl italic font-serif">"${slide.quote}"</p>
              ${slide.quoteAuthor ? `<p class="text-white/70 text-xl mt-4">— ${slide.quoteAuthor}</p>` : ''}
            </div>
          </div>` : '';
      }

      if (titleContainer) {
        titleContainer.innerHTML = (slide.title || slide.subtitle) ? `
          <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black via-black/80 to-transparent px-8 pb-8 pt-20">
            ${slide.title ? `<h1 class="text-white text-5xl font-bold mb-3">${slide.title}</h1>` : ''}
            ${slide.subtitle ? `<p class="text-white/80 text-2xl">${slide.subtitle}</p>` : ''}
          </div>` : '';
      }
    }

    // Full render (sidebar + preview + editor)
    function renderFull() {
      if (isOBSMode) { renderOBS(); return; }
      
      const slide = slides[currentIndex];
      const editSlide = slides.find(s => s.id === editingSlideId);
      const app = document.getElementById('app');
      
      app.innerHTML = `
        <div class="flex h-screen w-screen">
          <!-- Sidebar -->
          <div id="sidebar" class="w-64 bg-neutral-900 border-r border-white/10 flex flex-col">
            <div class="p-3 border-b border-white/10 flex items-center justify-between">
              <span class="text-white font-semibold text-sm">Slides (${slides.length})</span>
            </div>
            <div class="flex-1 overflow-y-auto scrollbar p-2 space-y-2">
              ${slides.map((s, i) => `
                <div onclick="goToSlide(${i})" class="cursor-pointer rounded-lg overflow-hidden border-2 transition-all ${i === currentIndex ? 'border-red-500 ring-2 ring-red-500/30' : 'border-transparent hover:border-white/20'}">
                  <div class="relative aspect-video bg-black">
                    ${s.type === 'video' ? `<video src="${s.url}" class="w-full h-full object-cover"></video>` : `<img src="${s.url}" class="w-full h-full object-cover">`}
                    <div class="absolute top-1 left-1 bg-black/80 text-white text-xs px-1.5 py-0.5 rounded">${i + 1}</div>
                    ${s.type === 'video' ? `<div class="absolute bottom-1 right-1 bg-black/80 text-white text-xs px-1 rounded">▶</div>` : ''}
                  </div>
                  <div class="p-2 bg-neutral-800/50" data-sidebar-info="${s.id}">
                    <p class="text-white text-xs font-medium truncate">${s.name || 'Untitled'}</p>
                    ${s.notes ? `<p class="text-gray-500 text-xs truncate">${s.notes}</p>` : ''}
                  </div>
                </div>`).join('')}
              <label class="flex items-center justify-center aspect-video border-2 border-dashed border-white/20 hover:border-white/40 rounded-lg cursor-pointer">
                <div class="text-center">
                  <svg class="w-8 h-8 text-gray-600 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg>
                  <span class="text-gray-500 text-xs mt-1 block">Add Media</span>
                </div>
                <input type="file" multiple accept="image/*,video/*" class="hidden" onchange="handleFileUpload(event)">
              </label>
            </div>
            <div class="p-3 border-t border-white/10 space-y-2">
              <div id="obs-button-container">
                <button onclick="openOBSWindow()" class="w-full ${isOBSConnected() ? 'bg-green-600 hover:bg-green-700' : 'bg-purple-600 hover:bg-purple-700'} text-white text-sm py-2 rounded-lg flex items-center justify-center gap-2">
                  ${isOBSConnected() ? `<span class="w-2 h-2 bg-white rounded-full animate-pulse"></span>` : `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/></svg>`}
                  ${isOBSConnected() ? 'OBS Connected' : 'OBS Output Window'}
                </button>
              </div>
              <button onclick="showSettings = !showSettings; renderFull();" class="w-full bg-white/5 hover:bg-white/10 text-gray-300 text-sm py-2 rounded-lg flex items-center justify-center gap-2 border border-white/10">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
                Settings
              </button>
            </div>
          </div>

          ${showSettings ? renderSettingsPanel() : ''}
          
          <!-- Main Preview -->
          <div class="flex-1 flex flex-col min-w-0 bg-neutral-950">
            <div class="flex-1 flex items-center justify-center p-6">
              <div id="preview-box" class="relative w-full max-w-5xl bg-black rounded-xl overflow-hidden shadow-2xl border border-white/10" style="aspect-ratio:16/9">
                ${renderPreviewContent(slide)}
              </div>
            </div>
            <div id="nav-bar" class="p-4 border-t border-white/10">
              ${renderNavBar(slide)}
            </div>
          </div>
          
          <!-- Editor Panel -->
          ${editSlide ? renderEditorPanel(editSlide) : ''}
        </div>`;

      // Attach event listeners after render
      if (editSlide) attachEditorListeners(editSlide);
      if (showSettings) attachSettingsListeners();
    }

    // Render just the preview content (called on input changes)
    function renderPreviewContent(slide) {
      if (!slide) return `
        <div class="absolute inset-0 flex items-center justify-center">
          <div class="text-center">
            <svg class="w-16 h-16 text-gray-700 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/></svg>
            <p class="text-gray-500">Add slides to get started</p>
          </div>
        </div>`;

      const kb = slide.kenBurns;
      const kbClass = kb === 'zoomIn' ? 'kb-zoom-in' : kb === 'zoomOut' ? 'kb-zoom-out' : kb === 'panLeft' ? 'kb-pan-left' : kb === 'panRight' ? 'kb-pan-right' : '';

      // Fit mode classes
      const fitMode = slide.fitMode || 'contain';
      let fitClass = 'max-w-full max-h-full object-contain'; // default: contain
      if (fitMode === 'cover') {
        fitClass = 'w-full h-full object-cover';
      } else if (fitMode === 'fill') {
        fitClass = 'w-full h-full object-fill';
      }

      // Zoom transform
      const zoom = slide.zoom || 100;
      const zoomStyle = zoom !== 100 ? `transform: scale(${zoom / 100});` : '';

      return `
        <div class="slide-container absolute inset-0">
          <div class="absolute inset-0 scale-150">
            ${slide.type === 'video' ?
              `<video id="bgVideo" src="${slide.url}" class="w-full h-full object-cover blur-3xl opacity-50" muted loop></video>` :
              `<img src="${slide.url}" class="w-full h-full object-cover blur-3xl opacity-50">`}
          </div>
          <div class="absolute inset-0 bg-gradient-to-b from-black/20 via-transparent to-black/40"></div>
          <div class="absolute inset-0 flex items-center justify-center overflow-hidden">
            ${slide.type === 'video' ?
              `<video id="mainVideo" src="${slide.url}" class="${fitClass} ${kbClass}" style="--kb-duration:${slide.kenBurnsDuration}s; ${zoomStyle}" loop playsinline></video>` :
              `<img src="${slide.url}" class="${fitClass} ${kbClass}" style="--kb-duration:${slide.kenBurnsDuration}s; ${zoomStyle}">`}
          </div>
          ${slide.quote ? `
            <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center max-w-3xl px-6 z-10">
              <div class="bg-black/60 backdrop-blur-md rounded-xl p-6 border border-white/10">
                <p class="text-white text-xl italic font-serif">"${slide.quote}"</p>
                ${slide.quoteAuthor ? `<p class="text-white/70 text-base mt-3">— ${slide.quoteAuthor}</p>` : ''}
              </div>
            </div>` : ''}
          ${slide.title || slide.subtitle ? `
            <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black via-black/80 to-transparent px-6 pb-6 pt-14">
              ${slide.title ? `<h1 class="text-white text-3xl font-bold mb-2">${slide.title}</h1>` : ''}
              ${slide.subtitle ? `<p class="text-white/80 text-lg">${slide.subtitle}</p>` : ''}
            </div>` : ''}
        </div>`;
    }

    function renderNavBar(slide) {
      return `
        <div class="flex items-center justify-center gap-4">
          <button onclick="goPrev()" class="bg-white/10 hover:bg-white/20 text-white p-2.5 rounded-xl border border-white/10">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
          </button>
          <span class="text-white font-medium min-w-[60px] text-center">${slides.length ? `${currentIndex + 1} / ${slides.length}` : '0 / 0'}</span>
          <button onclick="goNext()" class="bg-white/10 hover:bg-white/20 text-white p-2.5 rounded-xl border border-white/10">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
          </button>
          ${slide?.type === 'video' ? `
            <div class="w-px h-8 bg-white/20"></div>
            <button onclick="togglePlay()" id="playBtn" class="bg-red-600 hover:bg-red-700 text-white p-2.5 rounded-xl">
              ${isPlaying ? `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>` : `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`}
            </button>` : ''}
          <div class="w-px h-8 bg-white/20"></div>
          <button onclick="editingSlideId = slides[currentIndex]?.id; renderFull();" class="bg-white/10 hover:bg-white/20 text-white p-2.5 rounded-xl border border-white/10 ${editingSlideId ? 'ring-2 ring-blue-500' : ''}">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/></svg>
          </button>
        </div>
        <div class="flex justify-center gap-6 mt-3 text-xs text-gray-500">
          <span><kbd class="bg-neutral-800 px-1.5 py-0.5 rounded">←</kbd> <kbd class="bg-neutral-800 px-1.5 py-0.5 rounded">→</kbd> Navigate</span>
          ${slide?.type === 'video' ? `<span><kbd class="bg-neutral-800 px-2 py-0.5 rounded">Space</kbd> Play/Pause</span>` : ''}
        </div>`;
    }

    function updateNavBar() {
      const navBar = document.getElementById('nav-bar');
      if (navBar) navBar.innerHTML = renderNavBar(slides[currentIndex]);
    }

    function renderEditorPanel(slide) {
      return `
        <div class="w-80 bg-neutral-900 border-l border-white/10 flex flex-col">
          <div class="p-4 border-b border-white/10 flex items-center justify-between">
            <h3 class="text-white font-semibold">Edit Slide</h3>
            <button onclick="editingSlideId = null; renderFull();" class="text-gray-400 hover:text-white p-1 rounded hover:bg-white/10">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
            </button>
          </div>
          <div class="flex-1 overflow-y-auto scrollbar p-4 space-y-4">
            <div class="aspect-video rounded-lg overflow-hidden bg-black border border-white/10">
              ${slide.type === 'video' ? `<video src="${slide.url}" class="w-full h-full object-contain"></video>` : `<img src="${slide.url}" class="w-full h-full object-contain">`}
            </div>
            
            <div>
              <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide">Slide Name</label>
              <input type="text" id="ed-name" value="${slide.name || ''}" placeholder="Name for sidebar...">
            </div>
            
            <div>
              <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide">Notes (not displayed)</label>
              <textarea id="ed-notes" rows="2" placeholder="Your notes...">${slide.notes || ''}</textarea>
            </div>
            
            <hr class="border-white/10">
            
            <div>
              <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide">Display Title</label>
              <input type="text" id="ed-title" value="${slide.title || ''}" placeholder="Title on slide...">
            </div>
            
            <div>
              <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide">Display Subtitle</label>
              <input type="text" id="ed-subtitle" value="${slide.subtitle || ''}" placeholder="Subtitle on slide...">
            </div>
            
            <hr class="border-white/10">
            
            <div>
              <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide">Quote</label>
              <textarea id="ed-quote" rows="3" placeholder="Quote text...">${slide.quote || ''}</textarea>
            </div>
            
            <div>
              <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide">Quote Author</label>
              <input type="text" id="ed-quoteAuthor" value="${slide.quoteAuthor || ''}" placeholder="— Author">
            </div>
            
            <hr class="border-white/10">
            
            <div>
              <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide">Ken Burns Effect</label>
              <select id="ed-kenBurns">
                <option value="none" ${slide.kenBurns === 'none' ? 'selected' : ''}>None</option>
                <option value="zoomIn" ${slide.kenBurns === 'zoomIn' ? 'selected' : ''}>Slow Zoom In</option>
                <option value="zoomOut" ${slide.kenBurns === 'zoomOut' ? 'selected' : ''}>Slow Zoom Out</option>
                <option value="panLeft" ${slide.kenBurns === 'panLeft' ? 'selected' : ''}>Slow Pan Left</option>
                <option value="panRight" ${slide.kenBurns === 'panRight' ? 'selected' : ''}>Slow Pan Right</option>
              </select>
            </div>
            
            <div>
              <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide">Effect Duration: <span id="ed-duration-label" class="text-white">${slide.kenBurnsDuration}s</span></label>
              <input type="range" id="ed-kenBurnsDuration" min="10" max="120" step="5" value="${slide.kenBurnsDuration}">
              <div class="flex justify-between text-xs text-gray-600 mt-1"><span>10s</span><span>60s</span><span>120s</span></div>
            </div>

            <hr class="border-white/10">

            <div>
              <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide">Fit Mode</label>
              <div class="grid grid-cols-3 gap-2" id="fitmode-buttons">
                <button onclick="setFitMode('contain')" class="px-2 py-1.5 rounded text-xs font-medium transition-all ${(slide.fitMode || 'contain') === 'contain' ? 'bg-red-600 text-white' : 'bg-white/5 text-gray-300 hover:bg-white/10 border border-white/10'}">
                  Contain
                </button>
                <button onclick="setFitMode('cover')" class="px-2 py-1.5 rounded text-xs font-medium transition-all ${slide.fitMode === 'cover' ? 'bg-red-600 text-white' : 'bg-white/5 text-gray-300 hover:bg-white/10 border border-white/10'}">
                  Cover
                </button>
                <button onclick="setFitMode('fill')" class="px-2 py-1.5 rounded text-xs font-medium transition-all ${slide.fitMode === 'fill' ? 'bg-red-600 text-white' : 'bg-white/5 text-gray-300 hover:bg-white/10 border border-white/10'}">
                  Fill
                </button>
              </div>
              <p class="text-xs text-gray-600 mt-1.5">Contain = letterbox, Cover = crop to fill, Fill = stretch</p>
            </div>

            <div>
              <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide">Zoom: <span id="ed-zoom-label" class="text-white">${slide.zoom || 100}%</span></label>
              <input type="range" id="ed-zoom" min="50" max="200" step="5" value="${slide.zoom || 100}">
              <div class="flex justify-between text-xs text-gray-600 mt-1"><span>50%</span><span>100%</span><span>200%</span></div>
            </div>

            <hr class="border-white/10">

            <button onclick="deleteSlide(${slide.id})" class="w-full bg-red-600/10 hover:bg-red-600 border border-red-500/30 hover:border-red-500 text-red-400 hover:text-white rounded-lg py-2.5 flex items-center justify-center gap-2 transition text-sm">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
              Delete Slide
            </button>
          </div>
        </div>`;
    }

    // Render global settings panel
    function renderSettingsPanel() {
      return `
        <div class="w-72 bg-neutral-900 border-r border-white/10 flex flex-col">
          <div class="p-4 border-b border-white/10 flex items-center justify-between">
            <h3 class="text-white font-semibold">Settings</h3>
            <button onclick="showSettings = false; renderFull();" class="text-gray-400 hover:text-white p-1 rounded hover:bg-white/10">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
            </button>
          </div>
          <div class="flex-1 overflow-y-auto scrollbar p-4 space-y-5">
            <div>
              <label class="block text-xs text-gray-400 mb-2 uppercase tracking-wide">Transition Effect</label>
              <div class="grid grid-cols-2 gap-2" id="transition-buttons">
                ${['cut', 'fade', 'blur', 'slideLeft', 'slideRight', 'zoom', 'whipPan'].map(t => `
                  <button onclick="setTransition('${t}')" class="px-3 py-2 rounded-lg text-xs font-medium transition-all ${globalSettings.transition === t ? 'bg-red-600 text-white' : 'bg-white/5 text-gray-300 hover:bg-white/10 border border-white/10'}">
                    ${t === 'cut' ? 'Cut' : t === 'fade' ? 'Fade' : t === 'blur' ? 'Blur' : t === 'slideLeft' ? 'Slide ←' : t === 'slideRight' ? 'Slide →' : t === 'zoom' ? 'Zoom' : 'Whip Pan'}
                  </button>
                `).join('')}
              </div>
            </div>

            <div>
              <label class="block text-xs text-gray-400 mb-2 uppercase tracking-wide">Transition Duration: <span id="settings-duration-label" class="text-white">${globalSettings.transitionDuration}s</span></label>
              <input type="range" id="settings-transitionDuration" min="0.1" max="2" step="0.1" value="${globalSettings.transitionDuration}" class="w-full">
              <div class="flex justify-between text-xs text-gray-600 mt-1"><span>0.1s</span><span>1s</span><span>2s</span></div>
            </div>

            <hr class="border-white/10">

            <div>
              <label class="block text-xs text-gray-400 mb-2 uppercase tracking-wide">Default Ken Burns</label>
              <select id="settings-defaultKenBurns" class="w-full">
                <option value="none" ${globalSettings.defaultKenBurns === 'none' ? 'selected' : ''}>None</option>
                <option value="zoomIn" ${globalSettings.defaultKenBurns === 'zoomIn' ? 'selected' : ''}>Slow Zoom In</option>
                <option value="zoomOut" ${globalSettings.defaultKenBurns === 'zoomOut' ? 'selected' : ''}>Slow Zoom Out</option>
                <option value="panLeft" ${globalSettings.defaultKenBurns === 'panLeft' ? 'selected' : ''}>Slow Pan Left</option>
                <option value="panRight" ${globalSettings.defaultKenBurns === 'panRight' ? 'selected' : ''}>Slow Pan Right</option>
              </select>
            </div>

            <hr class="border-white/10">

            <div class="p-3 bg-white/5 rounded-lg border border-white/10">
              <p class="text-xs text-gray-400 mb-2">Preview Transition</p>
              <button onclick="previewTransition()" class="w-full bg-blue-600 hover:bg-blue-700 text-white text-sm py-2 rounded-lg">
                Test Transition
              </button>
            </div>
          </div>
        </div>`;
    }

    // Set transition type
    function setTransition(type) {
      globalSettings.transition = type;
      syncWindowState();
      renderFull();
    }

    // Preview transition effect
    function previewTransition() {
      if (slides.length < 2) return;
      const nextIndex = (currentIndex + 1) % slides.length;
      goToSlide(nextIndex);
    }

    // Attach settings panel listeners
    function attachSettingsListeners() {
      const durationSlider = document.getElementById('settings-transitionDuration');
      const durationLabel = document.getElementById('settings-duration-label');
      if (durationSlider) {
        durationSlider.addEventListener('input', (e) => {
          globalSettings.transitionDuration = parseFloat(e.target.value);
          if (durationLabel) durationLabel.textContent = globalSettings.transitionDuration + 's';
          syncWindowState();
        });
      }

      const defaultKenBurns = document.getElementById('settings-defaultKenBurns');
      if (defaultKenBurns) {
        defaultKenBurns.addEventListener('change', (e) => {
          globalSettings.defaultKenBurns = e.target.value;
          syncWindowState();
        });
      }
    }

    // Attach event listeners to editor inputs (without causing re-render)
    function attachEditorListeners(slide) {
      const fields = ['name', 'notes', 'title', 'subtitle', 'quote', 'quoteAuthor'];
      
      fields.forEach(field => {
        const el = document.getElementById('ed-' + field);
        if (el) {
          el.addEventListener('input', (e) => {
            slide[field] = e.target.value;
            updatePreviewOnly();
            updateSidebarInfo(slide);
            syncWindowState();
            pushToOBS();
          });
        }
      });
      
      const kenBurnsSelect = document.getElementById('ed-kenBurns');
      if (kenBurnsSelect) {
        kenBurnsSelect.addEventListener('change', (e) => {
          slide.kenBurns = e.target.value;
          updatePreviewOnly();
          syncWindowState();
          pushToOBS();
        });
      }
      
      const durationSlider = document.getElementById('ed-kenBurnsDuration');
      const durationLabel = document.getElementById('ed-duration-label');
      if (durationSlider) {
        durationSlider.addEventListener('input', (e) => {
          slide.kenBurnsDuration = parseInt(e.target.value);
          if (durationLabel) durationLabel.textContent = slide.kenBurnsDuration + 's';
          updatePreviewOnly();
          syncWindowState();
          pushToOBS();
        });
      }

      // Zoom slider
      const zoomSlider = document.getElementById('ed-zoom');
      const zoomLabel = document.getElementById('ed-zoom-label');
      if (zoomSlider) {
        zoomSlider.addEventListener('input', (e) => {
          slide.zoom = parseInt(e.target.value);
          if (zoomLabel) zoomLabel.textContent = slide.zoom + '%';
          updatePreviewOnly();
          syncWindowState();
          broadcast();
        });
      }
    }

    // Set fit mode for current slide
    function setFitMode(mode) {
      const slide = slides.find(s => s.id === editingSlideId);
      if (slide) {
        slide.fitMode = mode;
        updatePreviewOnly();
        syncWindowState();
        broadcast();
        // Re-render editor to update button states
        const editorContainer = document.querySelector('.w-80.bg-neutral-900');
        if (editorContainer) {
          editorContainer.outerHTML = renderEditorPanel(slide);
          attachEditorListeners(slide);
        }
      }
    }

    // Update only the preview box content (no re-render of inputs)
    function updatePreviewOnly() {
      const previewBox = document.getElementById('preview-box');
      if (previewBox) {
        previewBox.innerHTML = renderPreviewContent(slides[currentIndex]);
      }
    }

    // Update sidebar info for a slide
    function updateSidebarInfo(slide) {
      const info = document.querySelector(`[data-sidebar-info="${slide.id}"]`);
      if (info) {
        info.innerHTML = `
          <p class="text-white text-xs font-medium truncate">${slide.name || 'Untitled'}</p>
          ${slide.notes ? `<p class="text-gray-500 text-xs truncate">${slide.notes}</p>` : ''}`;
      }
    }

    // Initialize
    // Connect WebSocket for all modes (control panel and OBS)
    connectWebSocket();

    if (isOBSMode) {
      // OBS mode - render and sync via WebSocket (primary) or polling from parent window (fallback)
      renderOBS();

      // Sync state from opener window (parent control window) - fallback for popup windows
      function syncFromOpener() {
        try {
          if (window.opener && !window.opener.closed) {
            // Access parent window state - slides array may be empty initially
            const openerSlides = window.opener.slides;
            const openerVersion = window.opener.stateVersion;

            // Even if slides is empty, we should sync (to show "Waiting for slides")
            if (openerSlides !== undefined) {
              slides = openerSlides;
              currentIndex = window.opener.currentIndex ?? 0;
              isPlaying = window.opener.isPlaying ?? false;
              return openerVersion ?? 0;
            }
          }
        } catch (err) {
          // This will happen on file:// URLs due to cross-origin restrictions
          // WebSocket will handle sync in this case
        }
        return -1;
      }

      // Track last synced version and slide index for change detection
      let lastVersion = -1;
      let lastSlideIndex = -1;

      // Sync video playback state with main window (only works for popup windows)
      function syncVideoPlayback() {
        try {
          const mainVideo = window.opener?.document?.getElementById('mainVideo');
          const obsVideo = document.querySelector('.obs-main-video');
          const obsBgVideo = document.querySelector('.obs-bg-video');

          if (mainVideo && obsVideo) {
            // Sync play/pause state
            if (mainVideo.paused && !obsVideo.paused) {
              obsVideo.pause();
              if (obsBgVideo) obsBgVideo.pause();
            } else if (!mainVideo.paused && obsVideo.paused) {
              obsVideo.play();
              if (obsBgVideo) obsBgVideo.play();
            }

            // Sync current time if significantly different (>0.5s drift)
            if (Math.abs(mainVideo.currentTime - obsVideo.currentTime) > 0.5) {
              obsVideo.currentTime = mainVideo.currentTime;
              if (obsBgVideo) obsBgVideo.currentTime = mainVideo.currentTime;
            }

            // OBS video should NOT be muted (we want audio in OBS output)
            obsVideo.muted = false;
          }
        } catch (err) {
          // Cross-origin or element not found - WebSocket handles sync
        }
      }

      // Poll for opener window sync (fallback - WebSocket is primary for OBS browser sources)
      setInterval(() => {
        try {
          // Only use opener polling if opener exists (popup window mode)
          if (!window.opener || window.opener.closed) return;

          const openerVersion = window.opener?.stateVersion ?? -1;
          const openerIndex = window.opener?.currentIndex ?? 0;

          // Only re-render if version changed (indicates state was modified)
          if (openerVersion !== lastVersion && openerVersion >= 0) {
            const newVersion = syncFromOpener();
            if (newVersion >= 0) {
              // Check if slide actually changed (for enter transition)
              const slideChanged = openerIndex !== lastSlideIndex;
              console.log('OBS Poll: version changed', lastVersion, '->', newVersion,
                          'index:', lastSlideIndex, '->', openerIndex,
                          'slideChanged:', slideChanged);
              lastVersion = newVersion;
              lastSlideIndex = openerIndex;

              // Apply enter transition only when slide changes
              renderOBS(slideChanged);
            }
          }

          // Always sync video playback (even if state version hasn't changed)
          syncVideoPlayback();
        } catch (err) {
          // Window may have closed or cross-origin issue
        }
      }, 50);

    } else {
      renderFull();
    }
  </script>
</body>
</html>
